<template>
	<div v-show="visible" ref="ai" class="ai" @mousemove="mousemove" @mouseleave="mouseleave">
		<div class="codemirror-wrapper">
			<div v-show="!loading" ref="codemirror" :style="{'font-size': fontSize + 'px', 'line-height': lineHeight + 'px'}" :class="{search: searchEnabled}" class="codemirror"></div>
			<div v-if="errors" class="errors-band">
				<template v-for="(problems, entrypoint) of errors">
					<tooltip v-for="(error, p) of problems" :key="entrypoint + p">
						<template v-slot:activator="{ on }">
							<div :style="{top: (100 * error[0] / lines) + '%'}" :class="{warning: error[4] === 1, todo: error[4] === 2}" class="error" v-on="on" @click="$emit('jump', ai, error[0])"></div>
						</template>
						<v-icon v-if="error[4] === 0" class="tooltip error">mdi-close-circle-outline</v-icon>
						<v-icon v-else-if="error[4] === 1" class="tooltip warning">mdi-alert-circle-outline</v-icon>
						<v-icon v-else class="tooltip todo">mdi-format-list-checks</v-icon>
						<!-- {{ $i18n.t('ls_error.' + error[5], error[6]) }} -->
						{{ error[5] }}
					</tooltip>
				</template>
			</div>
		</div>
		<div v-show="searchEnabled" class="search-panel">
			<v-icon>mdi-magnify</v-icon>
			<input ref="searchInput" v-model="searchQuery" type="text" class="query" autocomplete="off" @keyup.enter="$event.shiftKey ? searchPrevious() : searchNext()">
			<span v-if="searchLines.length" class="results">{{ searchCurrent + 1 }} / {{ searchLines.length }}</span>
			<v-icon class="arrow" @click="searchPrevious">mdi-chevron-left</v-icon>
			<v-icon class="arrow" @click="searchNext">mdi-chevron-right</v-icon>
		</div>
		<div v-show="hintDialog" ref="hintDialog" :style="{left: hintDialogLeft + 'px', top: hintDialogTop + 'px'}" class="hint-dialog">
			<!-- <div v-if="completionType" class="type">
				<lw-type :type="completionType" />
			</div> -->
			<div ref="hints" class="hints">
				<div v-for="(hint, index) of hints" :key="index" :class="{active: selectedCompletion === index}" class="hint" @click="clickHint($event, index)">
					<v-icon v-if="hint.category === 0" class="method">mdi-alpha-m-circle-outline</v-icon>
					<v-icon v-else-if="hint.category === 1" class="field">mdi-cube-outline</v-icon>
					<v-icon v-else-if="hint.category === 2" class="function">mdi-function</v-icon>
					<v-icon v-else-if="hint.category === 3" class="constant">mdi-pi</v-icon>
					<v-icon v-else-if="hint.category === 4" class="user-function">mdi-function-variant</v-icon>
					<v-icon v-else-if="hint.category === 5" class="shortcut">mdi-flash-outline</v-icon>
					<v-icon v-else-if="hint.category === 6" class="variable">mdi-variable</v-icon>
					<v-icon v-else-if="hint.category === 7" class="argument">mdi-alpha</v-icon>
					<v-icon v-else-if="hint.category === 8" class="global">mdi-google</v-icon>
					<v-icon v-else-if="hint.category === 9" class="class">mdi-copyright</v-icon>
					<!-- <v-icon v-else class="variable">mdi-function</v-icon> -->
					{{ hint.fullName }}
					<!-- <lw-type :type="hint.lstype" /> -->
				</div>
			</div>
			<div v-if="selectedHint" class="details">
				<documentation-function v-if="selectedHint.type === 'function'" :fun="selectedHint.function" />
				<documentation-constant v-else-if="selectedHint.type === 'constant'" :constant="selectedHint.constant" />
				<weapon-preview v-else-if="selectedHint.details.type === 'weapon'" :weapon="selectedHint.details.weapon" />
				<chip-preview v-else-if="selectedHint.details.type === 'chip'" :chip="selectedHint.details.chip" />
				<javadoc v-else-if="selectedHint.javadoc" :javadoc="selectedHint.javadoc" class="main" />
				<span v-else v-html="selectedHint.details"></span>
			</div>
		</div>
		<div v-show="detailDialog" v-if="detailDialogContent" ref="detailDialog" :style="{left: detailDialogLeft + 'px', bottom: (!detailDialogAtBottom ? detailDialogTop + 'px' : 'auto'), top: (detailDialogAtBottom ? detailDialogTop + 'px' : 'auto'), 'max-height': detailDialogMaxHeight + 'px'}" class="detail-dialog" :class="{active: detailsDialogActive}" @mousemove="detailsDialogEnter" @mouseleave="detailsDialogLeave">
			<template v-if="detailDialogContent.keyword">
				<documentation-function v-if="detailDialogContent.keyword.type === 'function'" :fun="detailDialogContent.keyword.function" class="main" />
				<documentation-constant v-else-if="detailDialogContent.keyword.type === 'constant'" :constant="detailDialogContent.keyword.constant" class="main" />
				<weapon-preview v-else-if="detailDialogContent.keyword.details.type === 'weapon'" :weapon="detailDialogContent.keyword.details.weapon" class="main" />
				<chip-preview v-else-if="detailDialogContent.keyword.details.type === 'chip'" :chip="detailDialogContent.keyword.details.chip" class="main" />
				<javadoc v-if="detailDialogContent.keyword.javadoc" :javadoc="detailDialogContent.keyword.javadoc" class="main" />
			</template>
			<div v-if="detailDialogContent.details.defined" class="definition">
				<v-icon>mdi-file-outline</v-icon>
				<span @click="$emit('jump', detailDialogContent.keyword.ai, hoverData.defined[1])">
					<i18n class="defined" path="leekscript.defined_in">
						<b slot="0">{{ detailDialogContent.details.defined[0] }}</b>
						<b slot="1">{{ detailDialogContent.details.defined[1] }}</b>
					</i18n>
				</span>
			</div>
			<div v-if="detailDialogContent.details.alias && !detailDialogContent.details.op">
				<lw-code :code="detailDialogContent.details.alias" :single="true" />
			</div>
			<div v-if="detailDialogContent.details.type">
				<div v-if="detailDialogContent.details.op && detailDialogContent.details.type.args">
					<lw-type :type="detailDialogContent.details.type.args[0]" />
					{{ detailDialogContent.details.alias }}
					<lw-type :type="detailDialogContent.details.type.args[1]" />
					=
					<lw-type :type="detailDialogContent.details.type.return" />
				</div>
				<lw-type v-else :type="detailDialogContent.details.type" />
			</div>
			<template v-if="errorTooltip">
				<div v-if="errorLevel === 0" class="error"><v-icon class="error">mdi-close-circle-outline</v-icon> {{ errorTooltipText }}</div>
				<div v-else class="warning"><v-icon class="warning">mdi-alert-circle-outline</v-icon> {{ errorTooltipText }}</div>
			</template>
		</div>
		<loader v-if="loading" />
	</div>
</template>

<script lang="ts">
	import { Keyword } from '@/component/editor/keywords'
	import ChipPreview from '@/component/market/chip-preview.vue'
	import WeaponPreview from '@/component/market/weapon-preview.vue'
	import { AI } from '@/model/ai'
	import { fileSystem } from '@/model/filesystem'
	import { i18n } from '@/model/i18n'
	import { LeekWars } from '@/model/leekwars'
	import { store } from '@/model/store'
	import CodeMirror from 'codemirror'
	import { Component, Prop, Vue, Watch } from 'vue-property-decorator'
	import Code from '../app/code.vue'
	import DocumentationConstant from '../documentation/documentation-constant.vue'
	import DocumentationFunction from '../documentation/documentation-function.vue'
	import Javadoc from './javadoc.vue'

	const AUTO_SHORTCUTS = [
		["lama", "#LamaSwag", "", "Le pouvoir du lama"],
		["for", "for (var i = 0; i < ", "; i++) {\n\t\n}", "<h4>Boucle for</h4><br>for (var i = 0; i < ... ; i++) { ... }"],
		["while", "while (", ") {\n\t\n}", "<h4>Boucle while</h4><br>while ( ... ) { ... }"],
		["do", "do {\n\t\n} while (", ");", "<h4>Boucle do while</h4><br>do { ... } while( ... );"],
		["if", 'if (', ') {\n\t\n}', "<h4>Condition if</h4><br>if ( ... ) { ... }"]
	]

	@Component({ name: 'ai-view', components: {
		'weapon-preview': WeaponPreview,
		'chip-preview': ChipPreview,
		'documentation-function': DocumentationFunction,
		'documentation-constant': DocumentationConstant,
		'javadoc': Javadoc
	}})
	export default class AIView extends Vue {
		@Prop({required: true}) ai!: AI
		@Prop({required: true}) ais!: AI[]
		@Prop() visible!: boolean
		@Prop() fontSize!: number
		@Prop() lineHeight!: number
		@Prop() autoClosing!: boolean
		@Prop() autocompleteOption!: boolean
		@Prop() popups!: boolean
		@Prop() editors!: AIView[]

		public id!: number
		public editor!: CodeMirror.Editor
		public document!: CodeMirror.Doc
		public lines: number = 0
		public totalLines: number = 0
		public characters: number = 0
		public saving: boolean = false
		public loaded = false
		public loading: boolean = false
		public error!: boolean
		public needTest = false
		public activeLine: CodeMirror.LineHandle | null = null
		public pos: any
		public completionSelected: any
		public completionFrom: any
		public completionTo: any
		public hoverToken!: string
		public detailTimer: any
		public serverError: boolean = false
		public selectedCompletion: number = 0
		public completions: Keyword[] = []
		public dialogKeyMap: CodeMirror.KeyMap = {
			Up: this.up,
			Down: this.down,
			PageUp: this.up,
			PageDown: this.down,
			Home: this.top,
			End: this.bottom,
			Enter: this.pick,
			Tab: this.pick,
			Esc: this.close
		}
		public hintDialog: boolean = false
		public hintDialogTop: number = 0
		public hintDialogLeft: number = 0
		public hints: Keyword[] = []
		public selectedHint: Keyword | null = null
		public completionType: any = null
		public details: string[] = []
		public detailDialog: boolean = false
		public detailDialogContent: any = null
		public detailDialogTop: number = 0
		public detailDialogLeft: number = 0
		public detailDialogAtBottom: boolean = false
		public detailDialogMaxHeight: number = 0
		public detailsDialogActive: boolean = false
		public detailStart: number = 0
		public detailEnd: number = 0
		public searchOverlay: any = null
		public hoverOverlay: any = null
		public errorOverlays: {[key: number]: any} = {}
		public errors: {[key: number]: any} = {}
		public errorTooltip: boolean = false
		public errorTooltipText: string = ''
		public errorLevel: number = 0
		public searchEnabled: boolean = false
		public searchCurrent: number = 0
		public searchQuery: string = ''
		public searchLines: any = []
		public underlineMarker: CodeMirror.TextMarker | null = null
		public mouseX: number = -1
		public mouseY: number = -1
		private analyzerTimeout: any
		private hoverPosition: number = -1
		private hoverLine: number = -1
		private hoverLineWidth: number = 0
		private hoverEditorOrigin: number = 0
		private codemirror!: any
		private hoverData: any = null
		private ctrl: boolean = false
		private CodeMirrorLines!: HTMLElement

		created() {
			this.id = this.ai.id
			this.error = !this.ai.valid
		}
		mounted() {
			const codeMirrorElement = this.$refs.codemirror as any
			import(/* webpackChunkName: "codemirror" */ "@/codemirror-wrapper").then(wrapper => {
				this.codemirror = wrapper.CodeMirror
				this.editor = wrapper.CodeMirror(codeMirrorElement, {
					value: "",
					mode: "leekscript",
					theme: "leekwars",
					tabSize: 4,
					indentUnit: 4,
					indentWithTabs: true,
					highlightSelectionMatches: true,
					matchBrackets: true,
					lineNumbers: true,
					lineWrapping: true,
					continueComments: true,
					autofocus: true,
					smartIndent: true,
					cursorHeight: 1,
					foldGutter: true,
					gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
					extraKeys: {
						"Shift-Tab": () => this.unindentCode(),
						"Ctrl-D": () => this.duplicateLine(),
						"Ctrl-E": () => this.commentCode(),
						"Shift-Ctrl-/": () => this.commentCode(),
						"Ctrl-K": () => this.removeLine(),
						"Ctrl-Space": () => this.autocomplete(wrapper.CodeMirror, true),
						"Shift-Ctrl-F": () => this.formatCode(),
						"Alt-Left": () => null,
						"Alt-Right": () => null,
						"Alt-Up": () => this.invert(true),
						"Alt-Down": () => this.invert(false),
					},
				} as any)

				const overlay_javadoc = { token: (stream: any) => {
					if (stream.match("@")) {
						stream.eatWhile(/\w/)
						return "at"
					}
					if (!stream.skipTo("@")) {
						stream.skipToEnd()
					}
					return null
				}}
				const overlay_ref = { token: (stream: any) => {
					if (stream.match("#")) {
						stream.eatWhile(/\w/)
						return "ref"
					}
					if (!stream.skipTo("#")) {
						stream.skipToEnd()
					}
					return null
				}}
				const overlay_todo = { token: (stream: any) => {
					if (stream.match(/TODO/, false)) {
						if (stream.match(/TODO([^\w]|$)/)) {
							return "todo"
						} else {
							stream.next()
						}
					}
					if (!stream.skipTo("TODO")) {
						stream.skipToEnd()
					}
					return null
				}}
				this.editor.addOverlay(overlay_javadoc)
				this.editor.addOverlay(overlay_ref)
				this.editor.addOverlay(overlay_todo)

				this.document = this.editor.getDoc()

				this.editor.on('change', (_, changes) => this.change(wrapper.CodeMirror, changes))
				this.editor.on('cursorActivity', (_) => this.cursorChange())
				this.editor.on('keyup', (i: any, e: any) => {
					if (e.which === 46) {
						e.stopPropagation()
					}
				})

				this.show()

				this.CodeMirrorLines = codeMirrorElement.querySelector('.CodeMirror-lines') as HTMLElement

				// Lock scroll down
				const codeMirrorScroll = codeMirrorElement.querySelector('.CodeMirror-scroll') as HTMLElement
				if (codeMirrorScroll) {
					codeMirrorScroll.addEventListener('wheel', (e: WheelEvent) => {
						if (e.deltaY > 0 && Math.abs(codeMirrorScroll.scrollTop - (codeMirrorScroll.scrollHeight - codeMirrorScroll.offsetHeight + 15)) <= 1) {
							e.preventDefault()
						}
						// Clear details hover / popup
						this.detailDialog = false
						this.hoverData = null
						this.removeUnderlineMarker()
						if (this.hoverOverlay) {
							this.editor.removeOverlay(this.hoverOverlay)
							this.hoverOverlay = null
						}
					})
				}
				this.editor.on("mousedown", this.editorMousedown as any)
			})
		}
		@Watch('visible')
		visibilityChanged() {
			if (this.visible) {
				setTimeout(() => this.editor.refresh())
			}
		}
		public editorMousedown(editor: CodeMirror.Editor, e: MouseEvent) {
			if (e.ctrlKey && this.hoverData && this.hoverData.defined) {
				this.detailDialog = false
				const ai = fileSystem.aiByFullPath[this.hoverData.defined[0]]
				this.$emit('jump', ai, this.hoverData.defined[1])
				this.ctrl = false
				e.preventDefault()
			}
		}
		public editorKeyDown(e: KeyboardEvent) {
			if (e.keyCode === 17) {
				this.ctrl = true
				this.updateMouseAndCtrl()
			}
		}
		public editorKeyUp(e: KeyboardEvent) {
			if (e.keyCode === 17) {
				this.ctrl = false
				this.updateMouseAndCtrl()
			}
		}
		public hasBeenModified() {
			this.ai.modified = true
			this.removeAllErrors()
		}
		public show() {
			if (this.loaded) {
				this.editor.refresh()
			} else {
				this.loading = true
				LeekWars.get('ai/get/' + this.id).then(data => {
					Vue.set(this.ai, 'code', data.ai.code)
					this.editor.setValue(this.ai.code)
					this.editor.getDoc().clearHistory()
					this.editor.refresh()
					this.analyzeV1()
					this.loaded = true
					this.loading = false
					setTimeout(() => this.editor.refresh())
					this.lines = this.editor.getDoc().lineCount()
					this.characters = this.editor.getDoc().getValue().length
					Vue.set(this.ai, 'included_lines', this.ai.total_lines - this.lines)
					Vue.set(this.ai, 'included_chars', this.ai.total_chars - this.ai.code.length)
					LeekWars.setSubTitle(this.$i18n.tc('main.n_lines', this.lines))
				})
			}
		}

		public removeErrors(entrypoint: number) {
			// console.log("remove errors", this.ai.name)
			if (this.errorOverlays[entrypoint]) {
				this.editor.removeOverlay(this.errorOverlays[entrypoint])
				delete this.errorOverlays[entrypoint]
			}
			Vue.delete(this.errors, entrypoint)
			this.errorTooltip = false
			this.errorTooltipText = ''
		}

		public removeAllErrors() {
			for (const entrypoint in this.errorOverlays) {
				this.editor.removeOverlay(this.errorOverlays[entrypoint])
				Vue.delete(this.errorOverlays, entrypoint)
				Vue.delete(this.errors, entrypoint)
			}
			this.errorTooltip = false
			this.errorTooltipText = ''
		}

		public cursorChange() {
			const cursor = this.document.getCursor()
			if (!this.pos) {
				this.pos = cursor
			} else if (this.pos.line !== cursor.line) {
				this.close()
				this.pos = cursor
			}
			if (this.activeLine) { this.editor.removeLineClass(this.activeLine, "background", "activeline") }
			this.activeLine = this.editor.addLineClass(cursor.line, "background", "activeline")
		}

		public addErrorOverlay(entrypoint: number, errors: any) {
			if (this.errorOverlays[entrypoint]) {
				this.editor.removeOverlay(this.errorOverlays[entrypoint])
				Vue.delete(this.errorOverlays, entrypoint)
			}
			if (errors.length === 0) {
				Vue.delete(this.errors, entrypoint)
				return
			}
			Vue.set(this.errors, entrypoint, errors)
			const error_by_line = {} as any
			for (const error of errors) {
				if (error[4] >= 2) { continue }
				if (!(error[0] in error_by_line)) { error_by_line[error[0]] = [] }
				error_by_line[error[0]].push([error[1], error[3], error[4]])
			}
			// console.log(error_by_line)
			const overlay = { token: (stream: any) => {
				const line = stream.lineOracle.line + 1
				const pos = stream.pos
				if (line in error_by_line) {
					// console.log("line", line, pos, error_by_line[line])
					for (const error of error_by_line[line]) {
						if (pos === error[0]) {
							let len = Math.max(0, error[1] - error[0])
							stream.eatWhile(() => len-- >= 0)
							return error[2] === 0 ? "error" : "warning"
						}
						if (pos <= error[1]) {
							let len = error[0] - pos
							stream.eatWhile(() => len-- > 0)
							return null
						}
					}
					stream.skipToEnd()
				} else {
					stream.skipToEnd()
				}
			}}
			this.errorOverlays[entrypoint] = overlay
			this.editor.addOverlay(overlay, {priority: 12})
			this.error = true
		}

		setAnalyzerTimeout() {
			// this.analyze()
			clearTimeout(this.analyzerTimeout)
			this.analyzerTimeout = setTimeout(() => {
				this.analyzeV1()
			}, 500)
		}

		analyze() {
			const content = this.editor.getValue()
			return LeekWars.analyzer.analyze(this.ai, this.editor.getDoc().getValue()).then((problems) => {
				this.$emit('problems', problems)
			})
			.catch(() => {
				for (const entrypoint in this.errorOverlays) {
					this.editor.removeOverlay(this.errorOverlays[entrypoint])
					Vue.delete(this.errorOverlays, entrypoint)
				}
			})
		}

		public analyzeV1() {

			this.updateIncludes()

			// Search /* */ comments first
			let match
			const code = this.editor.getValue()
			const comments: {[key: number]: string} = {}
			const comment_regex = /\/\*([^]*?)\*\/\s*/gm
			while ((match = comment_regex.exec(code)) != null) {
				const content = match[1].trim().split("\n").map(line => line.replace(/^\s*\*\s?/, '')).join("\n").trim()
				comments[match.index + match[0].length] = content
			}
			this.ai.comments = comments

			// console.log("Comments", comments)

			this.updateFunctions()
			this.updateClasses()
			this.updateGlobalVars()
		}

		public change(CodeMirror: any, changes: CodeMirror.EditorChange) {
			const userChange = changes.origin === "+input" || changes.origin === "+delete"
			if (changes.origin !== "setValue") {
				this.hasBeenModified()
			}
			if (changes.origin === "+input" || (this.hintDialog && changes.origin === "+delete")) {
				// console.log(changes)
				if (changes.text.length === 1) { // One line of changes (no enter)
					this.autocomplete(CodeMirror)
				}
			}
			this.lines = this.editor.getDoc().lineCount()
			this.characters = this.editor.getDoc().getValue().length
			LeekWars.setSubTitle(this.$i18n.tc('main.n_lines', this.lines))
			this.mouseleave()

			if (changes.origin === "setValue") {
				this.analyze()
			} else {
				this.setAnalyzerTimeout()
			}

			if (userChange && this.autoClosing) {

				const chars = '{([\'"'
				const add = '})]\'"'
				let cursor = this.document.getCursor()
				let nextChar = this.document.getLine(cursor.line)[cursor.ch]

				// Peut etre une insertion d'un délimiteur
				if (changes.from.ch === changes.to.ch) {

					const pos = chars.indexOf(changes.text[0])
					const pos2 = add.indexOf(changes.text[0])

					if (pos2 > -1 && nextChar === changes.text[0]) {

						this.document.setSelection(cursor, {line: cursor.line, ch: cursor.ch + 1})
						this.document.replaceSelection("")

					} else if (changes.text[0].length > 0 && pos > -1) { // Délimiteur ouvrant

						const start = this.document.getCursor("from")
						const end = this.document.getCursor("to")

						this.document.replaceRange(add[pos], start, end)
						this.document.setSelection(end, end)
					}
				} else if (changes.text[0] === "" && changes.from.ch - changes.to.ch === -1 && changes.removed) { // Delete

					const pos = chars.indexOf(changes.removed[0])

					cursor = this.document.getCursor()
					nextChar = this.document.getLine(cursor.line)[cursor.ch]

					if (pos > -1 && add.indexOf(nextChar) === pos) { // Delete closing delimitor
						const start = this.document.getCursor("from")
						const end = this.document.getCursor("to")
						end.ch++
						this.document.setSelection(start, end)
						this.document.replaceSelection("")
						this.document.setSelection(start, start)
					}
				}
			}
		}
		public formatCode() {
			import(/* webpackChunkName: "js-beautify" */ "js-beautify").then(js_beautify => {
				console.log(js_beautify)
				this.editor.setValue(js_beautify.js_beautify(this.editor.getValue(), {indent_size: 1, indent_char: '\t'}))
			})
		}
		public commentCode() {
			const start = this.document.getCursor('from').line
			const end = this.document.getCursor('to').line

			let fullComments = true
			for (let i = 0; i < end - start + 1; i++) {
				const line = this.document.getLine(start + i).trim()
				if (line.length && !line.trim().startsWith('//')) {
					fullComments = false
					break
				}
			}
			for (let i = 0; i < end - start + 1; i++) {
				const line = this.document.getLine(start + i)
				let pos = 0
				for (let j = 0; j < line.length; j++) {
					if (line.charAt(j) === ' ' || line.charAt(j) === '\t') {
						pos++
					} else {
						break
					}
				}
				const cuttedLine = line.slice(pos)
				if (cuttedLine.length > 0) {
					const from = {line: start + i, ch: 0}
					const to = {line: start + i, ch: line.length}
					if (fullComments) {
						this.document.replaceRange(line.slice(0, pos) + line.slice(pos + 2), from, to) // Dé-Comment
					} else {
						this.document.replaceRange(line.slice(0, pos) + "//" + cuttedLine, from, to) // Comment
					}
				}
			}
		}
		public getLineIndentation(lineNo: number) {
			const line = this.document.getLine(lineNo)
			let indent = ""
			for (const l of line) {
				if (l === ' ' || l === '\t') {
					indent += l
				} else {
					break
				}
			}
			return indent
		}
		public unindentCode() {
			const start = this.document.getCursor("start").line
			const end = this.document.getCursor("end").line
			for (let i = 0; i < end - start + 1; i++) {
				const line = this.document.getLine(start + i)
				if (line.length > 0) {
					this.editor.indentLine(start + i, "subtract")
				}
			}
		}
		public removeLine() {
			const line = this.document.getCursor("start").line
			if (this.document.somethingSelected()) {
				this.document.replaceSelection("")
			} else {
				this.document.replaceRange("", {line, ch: 0}, {line: line + 1, ch: 0})
			}
			this.document.setCursor(line)
		}
		public duplicateLine() {
			if (this.document.somethingSelected()) {
				const start = this.document.getCursor("start")
				const end = this.document.getCursor("end")
				const selection = this.document.getSelection()
				this.document.replaceSelection(selection + selection)
				this.document.setSelection(start, end)
			} else {
				const start = this.document.getCursor("start").line
				const line = this.document.getLine(start)
				this.document.replaceRange(line + "\n" + line, {line: start, ch: 0}, {line: start, ch: line.length})
			}
		}

		public invert(up: boolean) {
			const cursor = this.document.getCursor("start")
			const offset = up ? (-1) : 1
			const line1 = this.document.getLine(cursor.line)
			const line2 = this.document.getLine(cursor.line + offset)
			this.editor.replaceRange(line2, {line: cursor.line, ch: 0}, {line: cursor.line, ch: line1.length})
			this.editor.replaceRange(line1, {line: cursor.line + offset, ch: 0}, {line: cursor.line + offset, ch: line2.length})
			this.document.setCursor(cursor.line + offset, cursor.ch)
		}

		public getTokenInformation(token: string, pos: CodeMirror.Position | null = null, previousToken: CodeMirror.Token) {
			if (token.startsWith('@')) { token = token.substring(1) }
			let wrong_arguments = false
			for (const keyword of LeekWars.keywords) {
				if (keyword.name === token) {
					if (keyword.type === 'function' && pos) {
						const line = this.document.getLine(pos.line)
						let start = 0
						let par = 0
						let j = pos.ch
						let argCount = 0
						for (; j < line.length; ++j) {
							const c = line[j]
							if (c === '(') { if (par++ === 0) { start = j + 1 } }
							if (c === ')') { if (--par === 0) { break } }
							if (c === ',' && par === 1) { argCount++ }
						}
						const capture = line.substring(start, j)
						argCount = capture.trim() === '' ? 0 : argCount + 1
						if (argCount === keyword.argumentCount) {
							return keyword
						} else {
							wrong_arguments = true
						}
					} else {
						return keyword
					}
				}
			}
			if (wrong_arguments) {
				for (const keyword of LeekWars.keywords) {
					if (keyword.name === token) {
						return keyword
					}
				}
			}
			return this.searchSymbolInAI(this.ai, token, previousToken)
		}

		public searchSymbolInAI(startAI: AI, startSymbol: string, previousToken: CodeMirror.Token): Keyword | null {

			const visited = new Set<number>()

			const aux = (ai: AI, symbol: string): Keyword | null => {
				visited.add(ai.id)
				if (ai.functions) {
					for (const fun of ai.functions) {
						if (symbol === fun.name) {
							return fun
						}
					}
				}
				for (const g in ai.globals) {
					if (symbol === g) {
						return ai.globals[g]
					}
				}
				for (const s in ai.classes) {
					const clazz = ai.classes[s]
					if (symbol === s) {
						return clazz
					}
					if (previousToken.string === s && clazz.static_methods) {
						for (const method of clazz.static_methods) {
							if (symbol === method.name) {
								return method
							}
						}
					}
				}
				if (ai.includes) {
					for (const include of ai.includes) {
						if (visited.has(include.id)) { continue }
						const found = aux(include, symbol)
						if (found) {
							return found
						}
					}
				}
				return null
			}
			return aux(startAI, startSymbol)
		}

		public mousemove(e: any) {
			this.mouseX = e.pageX
			this.mouseY = e.pageY
			this.updateMouseAndCtrl()
		}

		public stringRealSize(str: string) {
			let s = 0
			for (const c of str) {
				if (c === '\t') { s += 4 }
				else { s++ }
			}
			return s
		}

		public updateMouseAndCtrl() {
			if (!this.popups || !this.editor) { return null }
			if (this.hintDialog) { return null }

			if (!this.ctrl && this.underlineMarker) {
				this.removeUnderlineMarker()
			}

			if (this.detailsDialogActive) { return }

			const pos = {left: this.mouseX - 4, top: this.mouseY}
			const editorPos = this.editor.coordsChar(pos, "window")
			const editorPos2 = {line: editorPos.line, ch: editorPos.ch + 1}
			const token = this.editor.getTokenAt(editorPos2, true)
			const previousToken = this.editor.getTokenAt({line: editorPos.line, ch: token.start - 1})
			// console.log("token", token, previousToken)

			// Underline
			if (this.ctrl && this.hoverData && this.hoverData.defined) {
				if (this.underlineMarker) { this.underlineMarker.clear() }
				this.underlineMarker = this.editor.getDoc().markText({line: editorPos.line, ch: token.start}, {line: editorPos.line, ch: token.end}, {className: 'cm-underlined'})
				this.togglePointerCursor(true)
			} else {
				this.removeUnderlineMarker()
			}

			if (editorPos.line !== this.hoverLine) {
				const current_line = this.document.getLine(editorPos.line)
				this.hoverLineWidth = this.stringRealSize(current_line) * 10.2358333333 + 4
				this.hoverEditorOrigin = this.CodeMirrorLines.getBoundingClientRect().left
				this.hoverLine = editorPos.line
				// console.log("line width", this.hoverLineWidth)
			}

			// console.log("origin", origin)
			const position = this.document.indexFromPos(editorPos)
			const pos_in_line = pos.left - this.hoverEditorOrigin

			// Leave the hover area?
			if (this.hoverData) {
				// console.log(position, this.hoverData.location[0][2], this.hoverData.location[1][2], pos_in_line, this.hoverLineWidth)
				if (position < this.hoverData.location[0][2] || position > this.hoverData.location[1][2] || pos_in_line > this.hoverLineWidth) {
					clearTimeout(this.detailTimer)
					this.hoverData = null
					this.removeUnderlineMarker()
					if (this.hoverOverlay) {
						this.editor.removeOverlay(this.hoverOverlay)
						this.hoverOverlay = null
					}
					this.detailDialog = false
				}
			}
			// console.log(this.hoverPosition, position)
			if (this.hoverPosition === position || pos_in_line > this.hoverLineWidth) {
				return
			}
			this.hoverPosition = position

			clearTimeout(this.detailTimer)
			this.detailTimer = setTimeout(() => {

				// console.log("getTokenInformation", token, previousToken)
				const keyword = this.getTokenInformation(token.string, editorPos2, previousToken)

				// console.log("hover at", position)
				LeekWars.analyzer.hover(this.ai, position).then((raw_data) => {

					// console.log(JSON.stringify(raw_data))
					// console.log(raw_data.location[0], raw_data.location[1])
					// console.log(raw_data)

					this.showHoverDetails(editorPos, keyword, raw_data)
				})
				.catch(() => {
					// console.log("cannot hover", token, editorPos)

					const error = this.showErrorDetails(editorPos)
					if (keyword || error) {
						const index = this.document.indexFromPos({line: editorPos.line, ch: token.start})
						const data = {
							location: [
								[editorPos2.line + 1, token.start, index],
								[editorPos2.line + 1, token.end - 1, index + token.string.length - 1]
							],
						} as any
						if (keyword && keyword.ai) {
							data.defined = [
								keyword.ai ? keyword.ai.path : '',
								keyword.line
							]
						}
						this.showHoverDetails(editorPos2, keyword, data)
					}
				})
			}, this.ctrl ? 0 : 400)
		}

		public showErrorDetails(editorPos: any) {
			// console.log("showErrorDetails", this.errors, editorPos)
			// Display error?
			// const tooltip = this.$refs.tooltip
			let shown = false
			for (const entrypoint in this.errors) {
				for (const error of this.errors[entrypoint]) {
					if (error[0] === editorPos.line + 1 && error[1] <= editorPos.ch && error[3] >= editorPos.ch) {
						// this.errorTooltipText = i18n.t('ls_error.' + error[5], error[6]) as string
						this.errorTooltipText = error[5]
						this.errorTooltip = true
						this.errorLevel = error[4]
						shown = true
						return true
					}
				}
			}
			if (!shown) { this.errorTooltip = false }
			return false
		}

		public showHoverDetails(editorPos: any, keyword: any, raw_data: any) {

			const startPos = { ch: raw_data.location[0][1], line: raw_data.location[0][0] - 1 }

			if (raw_data.location[0][2] !== 0 || raw_data.location[1][2] !== 0) { // Not position [0:0]
				this.hoverData = raw_data
				this.detailDialogContent = { details: raw_data, keyword }
				const offset = (this.$refs.ai as HTMLElement).getBoundingClientRect()
				const p = this.editor.cursorCoords(startPos, "page")
				const left = p.left - offset.left
				this.detailDialogTop = - p.top + offset.bottom - (this.lineHeight - this.fontSize * 1.2) / 2 + 2
				this.detailDialogLeft = left
				this.detailDialogAtBottom = false
				this.detailDialogMaxHeight = 999999
				this.detailDialog = true

				const fixPosition = () => {
					const detailDialog = this.$refs.detailDialog as HTMLElement
					if (!detailDialog) { return }
					const height = detailDialog.scrollHeight
					const top = window.innerHeight - this.detailDialogTop
					this.detailDialogMaxHeight = window.innerHeight - this.detailDialogTop - (window.innerHeight - offset.bottom)
					if (top - height - (window.innerHeight - offset.bottom) < 0 && top + this.fontSize + height <= window.innerHeight) { // Y'a moyen de positionner le dialogue en bas
						this.detailDialogAtBottom = true
						this.detailDialogTop = p.top - offset.top + this.lineHeight - (this.lineHeight - this.fontSize * 1.2) / 2 + 2
						this.detailDialogMaxHeight = window.innerHeight - top
					}
					const width = detailDialog.clientWidth
					if (left + width + offset.left > window.innerWidth - 20) {
						this.detailDialogLeft = window.innerWidth - width - offset.left - 20
					}
				}
				Vue.nextTick(fixPosition)

				const start_line = raw_data.location[0][0] - 1
				const start_char = raw_data.location[0][1]
				const end_line = raw_data.location[1][0] - 1
				const end_char = raw_data.location[1][1]

				const overlay = {token: (stream: any) => {
					const lineNo = stream.lineOracle.line
					if (lineNo >= start_line && lineNo <= end_line) {
						if (lineNo === start_line) {
							if (stream.pos < start_char) {
								stream.next()
								return
							} else if (lineNo !== end_line || stream.pos <= end_char) {
								stream.next()
								return "hover"
							}
						} else if (lineNo === end_line && stream.pos <= end_char) {
							stream.next()
							return "hover"
						} else {
							stream.skipToEnd()
							return "hover"
						}
					}
					stream.skipToEnd()
				}}
				if (this.hoverOverlay) {
					this.editor.removeOverlay(this.hoverOverlay)
				}
				this.hoverOverlay = overlay
				this.editor.addOverlay(overlay)

			} else {
				this.hoverData = null
				this.removeUnderlineMarker()
				if (this.hoverOverlay) {
					this.editor.removeOverlay(this.hoverOverlay)
					this.hoverOverlay = null
				}
				// clearTimeout(this.detailTimer)
				this.detailDialog = false
			}
		}

		public detailsDialogEnter() {
			this.detailsDialogActive = true
			clearTimeout(this.detailTimer)
		}

		public detailsDialogLeave() {
			this.detailsDialogActive = false
		}

		public removeUnderlineMarker() {
			if (this.underlineMarker) {
				this.underlineMarker.clear()
				this.underlineMarker = null
				this.togglePointerCursor(false)
			}
		}

		public togglePointerCursor(enabled: boolean) {
			const lines = (this.$refs.codemirror as HTMLElement).querySelector('.CodeMirror-lines') as HTMLElement
			if (lines) { lines.style.cursor = enabled ? "pointer" : "text" }
		}

		public mouseleave() {
			clearTimeout(this.detailTimer)
			if (!this.detailsDialogActive) {
				this.detailDialog = false
			}
			if (this.hoverOverlay) {
				this.editor.removeOverlay(this.hoverOverlay)
			}
			this.hoverOverlay = null
		}

		public autocomplete(CodeMirror: any, force: boolean = false) {
			if (!this.autocompleteOption) { return }

			const cursor = this.document.getCursor()
			const position = this.document.indexFromPos(cursor)

			// return
			const cur = this.document.getCursor()
			const token = this.editor.getTokenAt(cur)
			let startPos = token.start

			const previousLength = token.string.length
			token.string = token.string.trim()
			startPos += previousLength - token.string.length

			if (!force && token.string.length === 0) {
				this.close()
				return
			}
			token.state = CodeMirror.innerMode(this.document.getMode(), token.state).state
			const completions: Keyword[] = []
			const previousToken = this.editor.getTokenAt({ ch: token.start, line: cur.line })
			const tokenBeforeDot = token.string === '.' ? this.editor.getTokenAt({ ch: token.start, line: cur.line }) : this.editor.getTokenAt({ ch: token.start - 1, line: cur.line })
			const isDot = token.string === '.' || previousToken.string === '.'
			const start = token.string === '.' ? '' : token.string.toLowerCase()

			const maybeAdd = (data: string | Keyword) => {
				if (typeof data === 'string') {
					if (data.toLowerCase().indexOf(start.toLowerCase()) === 0) {
						completions.push({ name: data, fullName: data, details: i18n.t('leekscript.keyword', [data]) as string, type: 'keyword', category: 3 })
					}
				} else {
					if (data.name.toLowerCase().indexOf(start.toLowerCase()) === 0) {
						completions.push(data)
					}
				}
			}

			let currentClass = null
			for (const clazz of Object.values(this.ai.classes)) {
				if (clazz.line! > cursor.line) break
				currentClass = clazz
			}

			// console.log("autocomplete 2", { token, previousToken, tokenBeforeDot, start, isDot, cursor, currentClass })

			if (isDot) {

				if (tokenBeforeDot.string in this.ai.classes) {
					const clazz = this.ai.classes[tokenBeforeDot.string]
					for (const staticMethod of clazz.static_methods) {
						if (staticMethod.name.toLowerCase().indexOf(start) === 0) {
							completions.push(staticMethod)
						}
					}
					for (const static_field of clazz.static_fields) {
						if (static_field.name.toLowerCase().indexOf(start) === 0) {
							completions.push(static_field)
						}
					}
				}
				if (currentClass) {
					if (tokenBeforeDot.string === 'class') {
						for (const static_field of currentClass.static_fields) {
							if (static_field.name.toLowerCase().indexOf(start) === 0) {
								completions.push(static_field)
							}
						}
						for (const staticMethod of currentClass.static_methods) {
							if (staticMethod.name.toLowerCase().indexOf(start) === 0) {
								completions.push(staticMethod)
							}
						}
					}
					if (tokenBeforeDot.string === 'this') {
						for (const method of currentClass.methods) {
							if (method.name.toLowerCase().indexOf(start) === 0) {
								completions.push(method)
							}
						}
					}
				}

			} else {

				// Ajout des variables locales du code
				for (let v = token.state.localVars; v; v = v.next) {
					if (v.name !== "arguments" && v.name.toLowerCase().indexOf(start.toLowerCase()) === 0) {
						completions.push({name: v.name, fullName: v.name, details: i18n.t('leekscript.variable', [v.name]) as string, type: 'keyword', category: 6})
					}
				}
				if (token.state.context) {
					for (let context = token.state.context.prev; context; context = context.prev) {
						for (let v = context.vars; v; v = v.next) {
							if (v.name !== "arguments" && v.name.toLowerCase().indexOf(start.toLowerCase()) === 0) {
								completions.push({name: v.name, fullName: v.name, details: i18n.t('leekscript.variable', [v.name]) as string, type: 'keyword', category: 6})
							}
						}
					}
					for (let v = token.state.context.vars; v; v = v.next) {
						if (v.name !== "arguments" && v.name.toLowerCase().indexOf(start.toLowerCase()) === 0) {
							completions.push({name: v.name, fullName: v.name, details: i18n.t('leekscript.argument', [v.name]) as string, type: 'keyword', category: 7})
						}
					}
				}

				if (currentClass) {
					for (const staticMethod of currentClass.static_methods) {
						if (staticMethod.name.toLowerCase().indexOf(start) === 0) {
							completions.push(staticMethod)
						}
					}
					for (const method of currentClass.methods) {
						if (method.name.toLowerCase().indexOf(start) === 0) {
							completions.push(method)
						}
					}
				}

				// Variables globales
				for (const variable in this.ai.globals) {
					if (variable.toLowerCase().indexOf(start.toLowerCase()) === 0) {
						const keyword = this.ai.globals[variable]
						completions.push(keyword)
					}
				}
				// Classes
				for (const variable in this.ai.classes) {
					if (variable.toLowerCase().indexOf(start.toLowerCase()) === 0) {
						const keyword = this.ai.classes[variable]
						completions.push(keyword)
					}
				}
				// Includes globals
				for (const include of this.ai.includes) {
					const globals = this.ais[include.id].globals
					for (const variable in globals) {
						if (variable.toLowerCase().indexOf(start.toLowerCase()) === 0) {
							const keyword = globals[variable]
							completions.push(keyword)
						}
					}
				}
				// File functions
				for (const fun of this.ai.functions) {
					if (fun.name.toLowerCase().indexOf(start.toLowerCase()) === 0) {
						completions.push(fun)
					}
				}
				// Includes functions
				for (const include of this.ai.includes) {
					const functions = this.ais[include.id].functions
					if (functions) {
						for (const fun of functions) {
							if (fun.name.toLowerCase().indexOf(start.toLowerCase()) === 0) {
								completions.push(fun)
							}
						}
					}
				}
				// Ajout des fonctions
				LeekWars.keywords.forEach(maybeAdd)

				// Raccourcis
				for (const r in AUTO_SHORTCUTS) {
					if (AUTO_SHORTCUTS[r][0].indexOf(start.toLowerCase()) === 0) {
						completions.push({ name: AUTO_SHORTCUTS[r][0], fullName: AUTO_SHORTCUTS[r][0], details: AUTO_SHORTCUTS[r][3], type: 'shortcut', shortcut: parseInt(r, 10), category: 5 })
					}
				}
			}

			this.completions = completions
			this.completionFrom = {line: cur.line, ch: startPos}
			this.completionTo = {line: cur.line, ch: token.end}
			if (isDot) {
				this.completionFrom.ch++
			}

			if (completions.length === 0) {
				this.close()
			} else {
				this.hintDialog = true
				this.detailDialog = false
			}

			this.openCompletions(this.completions, cursor)

			return null

			LeekWars.analyzer.complete(this.ai, position).then(raw_data => {

				const raw_completions = raw_data.items
				this.completionType = raw_data.type
				// console.log(raw_data)

				const new_completions = raw_completions.sort().map((data: any) => {
					return {
						name: data.name,
						fullName: data.name,
						details: i18n.t('leekscript.keyword', [data.name]) as string,
						category: data.type,
						type: 'function',
						lstype: data.lstype,
						location: data.location
					}
				})

				this.completions = new_completions
				this.openCompletions(new_completions, cursor)
			})
		}

		public openCompletions(completions: any[], cursor: any) {

			if (completions.length === 0) {
				this.close()
			} else {
				this.hintDialog = true
				this.detailDialog = false

				const pos = this.editor.cursorCoords({line: cursor.line, ch: cursor.ch })
				const left = pos.left, top = pos.bottom
				const offset = (this.$refs.ai as HTMLElement).getBoundingClientRect()

				this.hintDialogTop = top - offset.top
				this.hintDialogLeft = left - offset.left

				this.hints = completions
				this.selectHint(0)

				this.editor.removeKeyMap(this.dialogKeyMap)
				this.editor.addKeyMap(this.dialogKeyMap)
			}
		}

		public clickHint(e: Event, index: number) {
			if (index === this.selectedCompletion) {
				this.pick()
			} else {
				this.selectHint(index)
			}
			this.editor.focus()
			e.stopPropagation()
			e.preventDefault()
			return false
		}
		public up() {
			this.selectHint(this.selectedCompletion === 0 ? (this.hints.length - 1) : this.selectedCompletion - 1)
		}
		public down() {
			this.selectHint((this.selectedCompletion + 1) % this.hints.length)
		}
		public top() {
			this.selectHint(0)
		}
		public bottom() {
			this.selectHint(this.hints.length - 1)
		}
		public selectHint(index: number) {
			this.selectedCompletion = index
			this.selectedHint = this.hints[index]
			Vue.nextTick(() => {
				const hints = this.$refs.hints as HTMLElement
				const hintList = (this.$refs.hintDialog as HTMLElement).querySelectorAll('.hint') as any
				const posIndex = Math.max(0, Math.round(index - (hints.offsetHeight / hintList[index].offsetHeight) / 2 + 1))
				if (hintList[posIndex]) {
					hints.scrollTo(0, -2 + hintList[posIndex].offsetTop)
				}
			})
		}
		public pick() {
			const completion = this.completions[this.selectedCompletion]
			const cursor = this.document.getCursor()

			const range = this.document.getRange(cursor, {line: cursor.line, ch: cursor.ch + 1})
			const addParameters = range !== '(' && !/\w/i.test(range)

			if (completion.type === 'user-method' || completion.type === 'user-static-method') {

				const pos = this.document.getCursor()
				const name = completion.fullName
				this.document.replaceRange(completion.fullName, {line: this.completionFrom.line, ch: this.completionFrom.ch}, this.completionTo)
				const argCount = name.includes('()') ? 0 : name.split(',').length
				if (addParameters && argCount > 0) {
					const firstArgLength = (argCount > 1 ? name.indexOf(',') : name.indexOf(')')) - name.indexOf('(') - 1
					this.document.setSelection(
						{line: pos.line, ch: this.completionFrom.ch + completion.name.length + 1},
						{line: pos.line, ch: this.completionFrom.ch + completion.name.length + 1 + firstArgLength}
					)
				}

			} else if (completion.type === 'function' || completion.type === 'user-function') {
				let name = completion.name
				if (addParameters) {
					name += "("
					let a = 0, i = 0
					for (const argument of completion.function!.arguments_names) {
						if (completion.function!.optional[i++]) continue
						if (a++ > 0) name += ", "
						name += argument
					}
					name += ")"
				}
				this.document.replaceRange(name, this.completionFrom, this.completionTo)
				// this.document.replaceRange(name, {line: completion_start[0] - 1, ch: completion_start[1]}, {line: completion_end[0] - 1, ch: completion_end[1]})
				const pos = this.document.getCursor()

				let argCount = name.split(',').length
				if (argCount === 1) {
					if (name.indexOf(')') - name.indexOf('(') === 1) { argCount = 0 }
				}
				if (completion.lstype && completion.lstype.args) {
					argCount = completion.lstype.args.length
				}

				if (addParameters && argCount > 0) {
					const firstArgLength = (argCount > 1 ? name.indexOf(',') : name.indexOf(')')) - name.indexOf('(') - 1
					this.document.setSelection({line: pos.line, ch: this.completionFrom.ch + completion.name.length + 1}, {line: pos.line, ch: this.completionFrom.ch + completion.name.length + 1 + firstArgLength})
				}
			} else if (completion.type === 'shortcut') {

				// Dirty : modify the history to avoid having the word selected after an undo.
				// Set head.ch = anchor.ch (no selection)
				const history = this.document.getHistory()
				history.done[history.done.length - 1].ranges[0].head.ch = history.done[history.done.length - 1].ranges[0].anchor.ch
				this.document.setHistory(history)
				const shortcut = AUTO_SHORTCUTS[completion.shortcut!]
				let pos = this.document.getCursor()
				const iniLine = pos.line
				const indent = this.getLineIndentation(iniLine)

				pos.ch = this.completionFrom.ch
				this.document.replaceRange(shortcut[1].replace(/\n/g, '\n' + indent) + shortcut[2].replace(/\n/g, '\n' + indent),this.completionFrom, this.completionTo)

				pos = this.document.getCursor()
				pos.line = iniLine + (shortcut[1].split("\n").length - 1)
				pos.ch = shortcut[1].length - shortcut[1].lastIndexOf("\n") - 1 + indent.length
				this.document.setCursor(pos)
			} else {
				this.document.replaceRange(completion.name, this.completionFrom, this.completionTo)
			}
			this.close()
		}
		public close() {
			this.hintDialog = false
			this.editor.removeKeyMap(this.dialogKeyMap)
		}
		public scrollToLine(line: number) {
			this.document.setCursor({line, ch: 0})
			const height = this.editor.getScrollInfo().clientHeight
			const coords = this.editor.charCoords({line, ch: 0}, "local")
			this.editor.scrollTo(null, (coords.top + coords.bottom - height) / 2)
		}

		public updateIncludes() {
			// console.log("Update includes", this.ai.name)
			// console.time("inc")
			this.ai.includes = []
			const code = this.document.getValue() || this.ai.code
			const regex = /include\s*\(\s*["'](.*?)["']\s*\)/gm
			let m
			while (m = regex.exec(code)) {
				const path = m[1]
				const included = fileSystem.find(path, this.ai.folder)
				if (included) {
					// console.log("Found included", path, this.ai.folder, included)
					this.ai.includes.push(included)
					this.$emit("load", included)
					LeekWars.analyzer.register(included).catch(e => {
						// nothing
					})
				} else {
					// console.warn("Included not found", path, this.ai.folder, included)
				}
			}
			for (const entrypoint_id of this.ai.entrypoints) {
				const entrypoint = fileSystem.ais[entrypoint_id]
				if (entrypoint) {
					this.$emit("load", entrypoint)
				}
			}
			// console.timeEnd("inc")
		}

		public updateFunctions() {
			const code = this.editor.getValue()
			this.ai.functions = []
			let match

			const regex = /function\s+(\w+)\s*\(([^]*?)\)\s*{/gm
			// Match [ full_match, javadoc, nom, arguments ]

			while ((match = regex.exec(code)) != null) {

				const line = code.substring(0, match.index).split("\n").length
				let args = match[2].split(",")
				if (args.length === 1 && args[0].trim() === '') { args = [] }
				for (const a in args) {
					args[a] = args[a].trim()
					if (args[a].startsWith('@')) {
						args[a] = args[a].substring(1)
					}
				}
				let fullName = match[1] + "(" + args.join(", ") + ")"
				let description = "<h4>" + i18n.t('leekscript.function_f', [fullName]) + "</h4><br>"
				description += i18n.t('leekscript.defined_in', [this.ai.name, line])

				const comment = this.ai.comments[match.index]
				const javadoc = {
					name: fullName,
					description: "",
					items: [] as any[]
				}
				// Add arguments from signature
				for (const arg of args) {
					javadoc.items.push({ type: 'param', name: arg, text: null})
				}
				// console.log(javadoc.items)
				if (comment) {
					const javadoc_lines = comment.split("\n")
					const javadoc_regex = /^\s*@(\w+)(?:\s+([a-zA-Z_\u00C0-\u024F\u1E00-\u1EFF]+)\s*:?\s*)?(?:\s*:\s*)?(.*)$/
					let match_javadoc
					for (const jline of javadoc_lines) {
						if (match_javadoc = javadoc_regex.exec(jline)) {
							// console.log(match_javadoc)
							const type = match_javadoc[1]
							let name = match_javadoc[2]
							let text = match_javadoc[3]
							if (type === 'return') {
								fullName += ' : ' + text
							} else if (type === 'param') {
								if (name) {
									name = name.trim()
									if (name.startsWith('@')) {
										name = name.substring(1)
									}
								}
								text = text.trim()
								if (text.startsWith('@')) {
									text = text.trim().substring(1)
								}
								if (args.includes(name) || args.includes(text)) {
									// console.log('arg', name, text)
									const existing = javadoc.items.find(i => i.type === 'param' && ((name.length && i.name === name) || (text.length && i.name === text)))
									// console.log('existing', existing)
									// existing.name = existing.text
									existing.text = text
									continue
								}
							}
							javadoc.items.push({ type, name, text })
						} else {
							// const star = jline.indexOf("*")
							// let formatted_line = jline.substring(star + 2)
							// if (l === javadoc_lines.length - 1) {
							// 	formatted_line = formatted_line.trim()
							// }
							if (jline.length) {
								if (javadoc.description.length) {
									javadoc.description += "\n"
								}
								javadoc.description += jline
							}
						}
					}
					// console.log("javadoc", javadoc)
				}

				// Escape
				javadoc.description = LeekWars.protect(javadoc.description)
				for (const item of javadoc.items) {
					item.name = item.name ? LeekWars.protect(item.name) : item.name
					item.text = item.text ? LeekWars.protect(item.text) : item.text
				}

				const fun = {
					name: match[1],
					fullName,
					details: description,
					type: 'user-function',
					argumentCount: args.length,
					arguments: args,
					ai: this.ai,
					line,
					javadoc,
					category: 4
				}
				// console.log(fun)
				this.ai.functions.push(fun)
			}
		}

		public updateClasses() {
			const code = this.editor.getValue()
			this.ai.classes = {}
			let match

			// Search classes
			const class_regex = /class\s+(\w+)\s*(extends|{)/gm
			while ((match = class_regex.exec(code)) != null) {
				const line = code.substring(0, match.index).split("\n").length
				const name = match[1]
				const comment = this.ai.comments[match.index]
				const javadoc = { name, description: comment, items: [] }
				this.ai.classes[name] = {
					name,
					fullName: name,
					details: "Classe <b>" + name + "</b>",
					type: 'class',
					ai: this.ai,
					line,
					category: 9,
					javadoc,
					fields: [],
					static_fields: [

					],
					methods: [],
					static_methods: []
				}
				if (this.ai.version >= 3) {
					this.ai.classes[name].static_fields.push(
						{ name: "name", fullName: "name", type: "static-field", category: 1, details: this.$t('leekscript.class_name') },
						{ name: "super", fullName: "super", type: "static-field", category: 1, details: this.$t('leekscript.class_super') },
						{ name: "fields", fullName: "fields", type: "static-field", category: 1, details: this.$t('leekscript.class_fields') },
						{ name: "staticFields", fullName: "staticFields", type: "static-field", category: 1, details: this.$t('leekscript.class_staticFields') },
						{ name: "methods", fullName: "methods", type: "static-field", category: 1, details: this.$t('leekscript.class_methods') },
						{ name: "staticMethods", fullName: "staticMethods", type: "static-field", category: 1, details: this.$t('leekscript.class_staticMethods') },
					)
				}
			}
			// console.log("Classes", this.ai.classes)

			// Search methods
			const method_regex = /(?:public\s+)?(?:(static)\s+)?(\w+)\s*\(([\w\s,]*)\)\s*{/gm
			while ((match = method_regex.exec(code)) != null) {

				const name = match[2]
				if (name === 'function' || name === 'for' || name === 'while' || name === 'if') continue

				const is_static = !!match[1]
				const line = code.substring(0, match.index).split("\n").length
				let args = match[3].split(",")
				if (args.length === 1 && args[0].trim() === '') { args = [] }
				for (const a in args) {
					args[a] = args[a].trim()
					if (args[a].startsWith('@')) {
						args[a] = args[a].substring(1)
					}
				}
				let fullName = match[2] + "(" + args.join(", ") + ")"
				let description = "<h4>" + i18n.t('leekscript.function_f', [fullName]) + "</h4><br>"
				description += i18n.t('leekscript.defined_in', [this.ai.name, line])

				const comment = this.ai.comments[match.index]
				// console.log("comment", comment)
				const javadoc = {
					name: fullName,
					description: "",
					items: [] as any[]
				}
				// Add arguments from signature
				for (const arg of args) {
					javadoc.items.push({ type: 'param', name: arg, text: null})
				}
				// console.log(javadoc.items)
				if (comment) {
					const javadoc_lines = comment.split("\n")
					const javadoc_regex = /^\s*@(\w+)(?:\s+([a-zA-Z_\u00C0-\u024F\u1E00-\u1EFF]+)\s*:?\s*)?(?:\s*:\s*)?(.*)$/
					let match_javadoc
					for (const jline of javadoc_lines) {
						if (match_javadoc = javadoc_regex.exec(jline)) {
							// console.log(match_javadoc)
							const type = match_javadoc[1]
							let name = match_javadoc[2]
							let text = match_javadoc[3]
							if (type === 'return') {
								fullName += ' : ' + text
							} else if (type === 'param') {
								if (name) {
									name = name.trim()
									if (name.startsWith('@')) {
										name = name.substring(1)
									}
								}
								text = text.trim()
								if (text.startsWith('@')) {
									text = text.trim().substring(1)
								}
								if (args.includes(name) || args.includes(text)) {
									// console.log('arg', name, text)
									const existing = javadoc.items.find(i => i.type === 'param' && ((name.length && i.name === name) || (text.length && i.name === text)))
									// console.log('existing', existing)
									// existing.name = existing.text
									existing.text = text
									continue
								}
							}
							javadoc.items.push({ type, name, text })
						} else {
							if (jline.length) {
								if (javadoc.description.length) {
									javadoc.description += "\n"
								}
								javadoc.description += jline
							}
						}
					}
					// console.log("javadoc", javadoc)
				}

				// Escape
				javadoc.description = LeekWars.protect(javadoc.description)
				for (const item of javadoc.items) {
					item.name = item.name ? LeekWars.protect(item.name) : item.name
					item.text = item.text ? LeekWars.protect(item.text) : item.text
				}

				// Find class
				let clazz = null
				for (const c in this.ai.classes) {
					if (this.ai.classes[c].line! > line) break
					clazz = this.ai.classes[c]
				}
				if (clazz) {
					const method = {
						name: match[2],
						fullName,
						details: description,
						type: is_static ? 'user-static-method' : 'user-method',
						argumentCount: args.length,
						arguments: args,
						ai: this.ai,
						line,
						javadoc,
						category: 4
					}
					// console.log(fun)
					if (is_static) {
						clazz.static_methods.push(method)
					} else {
						clazz.methods.push(method)
					}
				}
			}

			// console.log("classes " + this.ai.name, this.ai.classes)
		}

		public updateGlobalVars() {

			const code = this.editor.getValue()
			this.ai.globals = {}
			let match

			// Search global vars
			const global_regex = /global\s+(\w+)/gm
			while ((match = global_regex.exec(code)) != null) {
				const line = code.substring(0, match.index).split("\n").length
				const name = match[1]
				const comment = this.ai.comments[match.index]
				const javadoc = { name, description: comment, items: [] }
				this.ai.globals[name] = {
					name,
					fullName: name,
					details: "Variable <b>" + name + "</b>",
					type: 'variable',
					ai: this.ai,
					line,
					category: 8,
					javadoc,
				}
			}
		}

		public search() {
			const selection = this.document.getSelection()
			if (!this.searchEnabled || selection) {
				this.searchEnabled = true
				this.searchQuery = selection
				this.searchUpdate()
				Vue.nextTick(() => {
					if (this.$refs.searchInput) {
						(this.$refs.searchInput as HTMLElement).focus()
					}
				})
			} else {
				this.closeSearch()
			}
		}
		public closeSearch() {
			this.searchEnabled = false
			if (this.searchOverlay) {
				this.editor.removeOverlay(this.searchOverlay)
				this.searchOverlay = null
			}
		}
		@Watch('searchQuery')
		public searchUpdate() {
			const query = this.searchQuery.toLowerCase()
			this.searchCurrent = 0
			this.searchLines = []
			if (query.length > 0) {
				for (let l = 0; l < this.document.lineCount(); ++l) {
					const line = this.document.getLine(l)
					let index = -1
					while ((index = line.toLowerCase().indexOf(query, index + 1)) > -1) {
						this.searchLines.push([l, index])
					}
				}
				this.searchRefresh()
			} else {
				if (this.searchOverlay) {
					this.editor.removeOverlay(this.searchOverlay)
					this.searchOverlay = null
				}
			}
		}
		public searchRefresh() {
			const query = this.searchQuery.toLowerCase()
			// TODO improve this overlay speed
			const overlay = {token: (stream: any) => {
				const lineNo = stream.lineOracle.line
				if (stream.match(query, true, true)) {
					let index: any = -1
					for (let l = 0; l < this.searchLines.length; ++l) {
						if (this.searchLines[l][0] === lineNo && this.searchLines[l][1] === stream.start) {
							index = l
							break
						}
					}
					if (index === this.searchCurrent) {
						return "matchhighlight-green"
					}
					return "matchhighlight"
				}
				stream.next()
				const il = stream.string.indexOf(query.charAt(0), stream.pos)
				const iu = stream.string.indexOf(query.charAt(0).toUpperCase(), stream.pos)
				if (il === -1 && iu === -1) { stream.skipToEnd() }
				else if (iu === -1 || il < iu) { stream.skipTo(query.charAt(0)) }
				else { stream.skipTo(query.charAt(0).toUpperCase()) }
			}}
			if (this.searchOverlay) {
				this.editor.removeOverlay(this.searchOverlay)
			}
			this.searchOverlay = overlay
			this.editor.addOverlay(overlay)
			if (this.searchLines.length > 0) {
				const line = this.searchLines[this.searchCurrent][0]
				const t = this.editor.charCoords({line, ch: 0}, "local").top
				const middleHeight = this.editor.getScrollerElement().offsetHeight / 2
				this.editor.scrollTo(0, t - middleHeight - 5)
			}
		}
		public searchPrevious() {
			this.searchCurrent--
			if (this.searchCurrent < 0) { this.searchCurrent = this.searchLines.length - 1 }
			this.searchRefresh()
		}
		public searchNext() {
			this.searchCurrent = (this.searchCurrent + 1) % this.searchLines.length
			this.searchRefresh()
		}
	}
</script>

<style lang="scss" scoped>
	.ai {
		height: 100%;
		display: flex;
		flex-direction: column;
		position: relative;
	}
	.codemirror-wrapper {
		flex: 1;
		min-height: 0;
		position: relative;
	}
	.codemirror {
		height: 100%;
	}
	.loader {
		position: absolute;
		top: calc(50% - 35px);
		left: calc(50% - 35px);
	}
	.codemirror ::v-deep .line-error {
		position: relative;
	}
	.codemirror ::v-deep .line-error:after {
		position: absolute;
		bottom: -3px;
		left: 0;
		content: "";
		height: 20px;
		width: 100%;
		background-image: url("/image/squiggle.gif");
		background-repeat: repeat-x;
		background-position: left bottom;
		vertical-align: text-top;
	}
	.hint-dialog {
		position: absolute;
		z-index: 100;
		margin: 0;
		display: flex;
		align-items: flex-start;
		> .type {
			position: absolute;
			top: 0;
			left: 0;
			transform: translateX(-100%);
			font-family: monospace;
			font-size: 14px;
			line-height: 20px;
			padding: 2px 5px;
			background: #f7f7f7;
			border: 1px solid #ccc;
			border-right: none;
		}
	}
	.hint-dialog .hints {
		min-width: 400px;
		max-width: 600px;
		background: white;
		font-family: monospace;
		overflow-y: auto;
		overflow-x: hidden;
		vertical-align: top;
		max-height: 260px;
		background: #f7f7f7;
		border: 1px solid #ccc;
	}
	.hint-dialog .hint {
		margin: 0;
		padding: 2px 4px;
		white-space: pre;
		color: black;
		cursor: pointer;
		user-select: none;
		font-size: 14px;
		line-height: 20px;
		.v-icon {
			transition: none;
			font-size: 20px;
			margin-top: -2px;
			&.field {
				color: #074f86;
			}
			&.variable {
				color: #b12f2f;
			}
			&.function {
				color: #b12fa0;
			}
			&.constant {
				color: #cc7b2f;
			}
			&.user-function {
				color: #074f86;
			}
			&.shortcut {
				color: #1a8607;
			}
			&.argument {
				color: #078675;
			}
		}
		&.active {
			background: #d2e9ff;
		}
	}
	.hint-dialog .details {
		width: 500px;
		overflow-y: auto;
		background: #f7f7f7;
		border: 1px solid #ccc;
		margin-left: -1px;
		max-height: 600px;
		padding: 8px;
	}
	.detail-dialog {
		position: absolute;
		max-width: 600px;
		width: fit-content;
		z-index: 100;
		background: #f7f7f7;
		border: 1px solid #ccc;
		display: flex;
		flex-direction: column;
		&.active {
			box-shadow: 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12);
		}
		> * {
			display: block;
			padding: 5px 8px;
			&:not(:last-child) {
				border-bottom: 1px solid #ccc;
			}
		}
		.main {
			overflow-y: auto;
		}
		::v-deep .doc-constant.item {
			padding: 0 !important;
			min-width: 280px;
			max-width: 320px;
			h4 {
				margin-left: 6px;
				margin-right: 6px;
			}
			ul {
				margin: 10px;
			}
		}
		::v-deep .deprecated {
			opacity: 0.6;
		}
		::v-deep .deprecated-message {
			color: #ff7f00;
			font-weight: bold;
			margin: 10px 0;
		}
		> .error, > .warning {
			display: flex;
			align-items: center;
			padding: 5px 8px;
			.v-icon {
				margin-right: 4px;
				font-size: 20px;
				background: none;
			}
		}
		.error {
			background: rgba(255, 0, 0, 0.1);
			.v-icon {
				color: red;
			}
		}
		> .warning {
			background: rgba(255, 145, 0, 0.1);
			.v-icon {
				color: #ff9100;
			}
		}
		code.single {
			border: none;
		}
		.definition {
			cursor: pointer;
			span {
				// color: #5fad1b;
				color: #0000D0;
				// font-weight: 500;
			}
			span:hover {
				text-decoration: underline;
			}
			.v-icon {
				font-size: 16px;
				vertical-align: top;
				margin-right: 4px;
			}
		}
	}
	.search-panel {
		height: 40px;
		background: #eee;
		display: flex;
	}
	.search-panel .v-icon {
		width: 40px;
		height: 40px;
		padding: 8px;
	}
	.search-panel .arrow {
		opacity: 0.3;
		cursor: pointer;
	}
	.search-panel .arrow:hover {
		opacity: 1;
		background: rgba(127,127,127,0.5);
	}
	.search-panel input {
		width: 100%;
		height: 26px;
		margin: 7px 0;
		margin-right: 7px;
		border: none;
		background: #eee;
	}
	.search-panel .results {
		color: #777;
		margin-right: 13px;
		line-height: 40px;
		white-space: nowrap;
	}
	.errors-band {
		width: 10px;
		position: absolute;
		right: 0;
		top: 0;
		bottom: 0;
		.error {
			background: red;
			height: 10px;
			width: 100%;
			position: absolute;
			z-index: 6;
			cursor: pointer;
			&.warning {
				background: #ff9100;
			}
			&.todo {
				background: #0099ff;
			}
		}
	}
	.tooltip {
		&.error {
			color: red;
		}
		&.warning {
			color: #ff9100;
		}
		&.todo {
			color: #0099ff;
		}
	}
</style>
